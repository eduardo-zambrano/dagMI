% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qn_functional.R
\name{compute_qn}
\alias{compute_qn}
\title{Compute Q_n^G Functional}
\usage{
compute_qn(
  data,
  dag,
  ordering = NULL,
  method = NULL,
  n_quad = 10,
  n_mc = 10000,
  bandwidth = NULL
)
}
\arguments{
\item{data}{Numeric matrix with n observations and p variables (columns
ordered according to a topological ordering of the DAG)}

\item{dag}{A dag object specifying the DAG structure}

\item{ordering}{Optional topological ordering to use. If NULL, uses the
first valid ordering.}

\item{method}{Integration method: "quadrature" (default for n <= 5) or
"montecarlo" (default for n > 5)}

\item{n_quad}{Number of quadrature points per dimension (default 10)}

\item{n_mc}{Number of Monte Carlo samples (default 10000)}

\item{bandwidth}{Vector of bandwidths for KDE. If NULL, uses Silverman's rule.}
}
\value{
An object of class "qn_result" with components:
\item{qn}{The computed Q_n^G value}
\item{se}{Standard error (for Monte Carlo method)}
\item{method}{Integration method used}
\item{n_vars}{Number of variables}
\item{ordering}{Topological ordering used}
\item{kde_list}{List of KDE objects (for reuse)}
}
\description{
Computes the DAG-specific functional Q_n^G that appears in Carbery's
inequality. This is the key quantity that determines the bound in
the multilinear inequality.
}
\details{
Q_n^G is defined as:
\deqn{Q_n^G = \int \prod_{j=2}^n f_{j-1,j}(x_{j-1}, x_j)^{1/(n+1)}
      \cdot \prod_{j=1}^n f_j(x_j)^{-(n-1)/(n+1)} dx}

where f_j is the marginal density of X_j and f_{j-1,j} is the joint
density of consecutive pairs in the ordering.

For small n (n <= 5), tensor-product Gauss-Legendre quadrature is used.
For larger n, importance sampling Monte Carlo is more efficient.
}
\examples{
# Create simple chain DAG: X1 -> X2 -> X3
A <- matrix(c(0, 1, 0, 0, 0, 1, 0, 0, 0), 3, 3, byrow = TRUE)
g <- dag(A, nodes = c("X1", "X2", "X3"))

# Generate data
set.seed(123)
X1 <- rnorm(200)
X2 <- 0.5 * X1 + rnorm(200, sd = 0.5)
X3 <- 0.5 * X2 + rnorm(200, sd = 0.5)
data <- cbind(X1, X2, X3)

# Compute Q_n
result <- compute_qn(data, g)

}
