% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ordering.R
\name{select_ordering}
\alias{select_ordering}
\title{Select Optimal Ordering}
\usage{
select_ordering(data, dag, method = "optimal", max_orderings = 100, ...)
}
\arguments{
\item{data}{Numeric matrix with n observations and p variables}

\item{dag}{A dag object}

\item{method}{Selection method:
\itemize{
\item "optimal": Select ordering with maximum Q_n (default)
\item "first": Use first valid ordering
\item "random": Random valid ordering
\item "bonferroni": Test all orderings with Bonferroni correction
\item "fisher": Combine p-values using Fisher's method
}}

\item{max_orderings}{Maximum orderings to consider for "optimal" and "bonferroni"}

\item{...}{Additional arguments passed to compute_qn}
}
\value{
A list with:
\item{ordering}{The selected ordering}
\item{method}{Method used}
\item{qn}{Q_n value for selected ordering (for "optimal")}
\item{all_qn}{Q_n values for all orderings considered (for "optimal")}
}
\description{
Selects a topological ordering for the test based on data-driven criteria.
}
\details{
The choice of topological ordering can affect the test's power. The "optimal"
method selects the ordering that maximizes Q_n, which tends to give higher
power against alternatives.

For testing multiple orderings, "bonferroni" applies a Bonferroni correction
to control the family-wise error rate, while "fisher" combines individual
p-values using Fisher's combination method.
}
\examples{
A <- matrix(c(0, 1, 1, 0, 0, 0, 0, 0, 0), 3, 3, byrow = TRUE)
g <- dag(A, nodes = c("X1", "X2", "X3"))

set.seed(123)
data <- cbind(rnorm(100), rnorm(100), rnorm(100))

select_ordering(data, g, method = "optimal")

}
